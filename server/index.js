// лучше создать, подключить git репозиторий в проект,сделать первый commit и push данных в git до того,как создали папку с фронтендом на react js,иначе могут быть ошибки(могут и не быть) сохранений git папки всего проекта и git папки самого фронтенда на react js,поэтому сначала создаем папку с сервером(server в данном случае) и в ней просто создаем файл,а потом в корневой папке проекта подключаем git(указываем в терминале git init и тд,делаем первый commit и push данных в git),а только после этого создаем папку для react js,инициализируем проект с помощью npm init -y(указываем эту команду в терминале для папки сервера(server в данном случае), -y значит,что настройки ставим по дефолту), устанавливаем npm i express(типа node js express) express-ws(для более комфортной работы с вебсокетами),устанавливаем npm i -D nodemon(чтобы сервер перезагружался автоматически при сохранении файла, -D значит,что устанавливаем только для режима разработки),указываем в файле package.json в поле scripts поле "dev"(это поле можно назвать по-любому,это просто будет название команды,которое будем указываем в терминале) и значение ему "nodemon index.js"(то есть по команде npm run dev будет запускаться index.js файл,а указываем nodemon,чтобы сервер перезагружался автоматически при сохранении файла),добавляем поле type со значение module в package.json,чтобы работали импорты типа import from,устанавливаем npm i cors(чтобы отправлять запросы с браузера)

import express from 'express'; // импортируем express(express типа для node js express,в данном случае импортируем это вручную,потому что автоматически не импортируется)

import WSServer from 'express-ws'; // импортируем WSserver(вебсокет сервер) из express-ws для более комфортной работы с вебсокетами

import cors from 'cors'; // импортируем cors,чтобы отправлять запросы с браузера на сервер

import fs from 'fs'; // импортируем fs,чтобы работать с файлами

import path from 'path'; // импортируем path,чтобы корректно работать с путями файлов

const app = express();  // создаем экземпляр нашего приложения(сервера) с помощью express()

WSServer(app); // вызываем функцию WSserver и передаем туда наш app(наш сервер)

const PORT = process.env.PORT || 5000; // указываем переменную PORT и даем ей значение как у переменной PORT из файла .env,если такой переменной нет,то указываем значение 5000

const aWss = WSServer(app).getWss();  // с помощью getWss() у WSServer(app) (укаызваем именно WSServer(app),иначе не работает) получаем объект,с помощью которого сможем делать широковещательную рассылку(то есть отправлять сообщения разным пользователям)

app.use(cors()); // вызываем(подключаем) cors(),чтобы отправлять запросы с браузера на сервер

app.use(express.json()); // подключаем express.json(),чтобы наш сервер мог парсить(то есть преобразовывать из строки в обычный javascript объект) json формат

// так как мы установили express-ws,то он позволяет работать с вебсокетами также,как и с обычными http запросами,то есть также можно добавлять эндпоинты к url на сервере,в данном случае в app.ws() первым параметром указываем url,а вторым функцию callback,которая будет отрабатывать на этом эндпоинте(url),
app.ws('/',(ws, req) => {

    console.log('подключение установлено');

    // закомментировали этот код,так как из-за него получается ошибка,когда отправляем на клиент объект сообщения в функции broadcastConnection() и этот код сейчас уже не нужен
    // ws.send('Ты успешно подключился'); // отправляем сообщение на клиент с помощью ws.send(),вебсокеты не могут принимать javascript объекты,а могут работать только со строковым форматом данных,поэтому потом нужно будет парсить(JSON.parse()) или преобразовывать из объекта в строку(JSON.stringify()) при обмене сообщениями,если нужно будет работать с объектами

    // делаем логику отправки или обработки сообщений,первым параметром в ws.on() указываем тип события(в данном случае 'message'),а вторым функцию,которая в параметре принимает сообщение,которое было отправлено с клиента
    ws.on('message', (msg) => {

        msg = JSON.parse(msg); // парсим сообщение(msg) с помощью JSON.parse(),то есть приводим объект сообщения из формата строки в формат обычного javascript объекта

        // используем тут switch case,чтобы в зависимости от значения в поле method у msg(сообщения),отправлять разные сообщения на клиент(фронтенд),то есть проверяем поле method у msg на разные значения 
        switch (msg.method) {

            // если поле method у msg равно значению "connection"
            case "connection":
                
                connectionHandler(ws, msg) //.вызываем нашу функцию connectionHandler и параметрами передаем ws(вебсокет) и msg(сообщение,которое получили)

                break // указываем break,чтобы остановить код этого case

            // если поле method у msg равно значению "draw"
            case "draw":
                
                broadcastConnection(ws, msg) //.вызываем нашу функцию broadcastConnection и параметрами передаем ws(вебсокет) и msg(сообщение,которое получили)

                break // указываем break,чтобы остановить код этого case

        }

        console.log(msg); // выводим объект сообщения

    })

})



app.post('/image', (req,res) => {

    // используем try catch для обработки ошибок
    try{
        
        const data = req.body.img.replace(`data:image/png;base64,`, ''); // получаем поле img из тела запроса(req.body) и используем метод replace(),первым параметром в него передаем кусок строки,который нужно заменить,а вторым параметром указываем то,на что этот кусок строки будет заменен,то есть в данном случае из поля img убираем кусок строки,заменяя его на пустую строку,то есть убираем его и помещаем результат в переменную data,убираем этот кусок строки,так как он не нужен

        fs.writeFileSync(path.resolve('files',`${req.query.id}.jpg`),data, 'base64'); // с помощью writeFileSync() записываем файл в папку,которую передаем параметром в эту функцию writeFileSync(),передаем путь до папки с помощью path.resolve() (он берет относительный путь до корневой папки,в данном случае до папки server),передаем в нее название папки,в которую нужно сохранить файл(files в данном случае),и потом указываем название файлу,который будет сохранен,берем это название из id(req.query.id),который будем передавать query параметром в url к этому эндпоинту,то есть это тот самый id сессии,также добавляем .jpg к названию файла,чтобы в итоге сохранялось изображение,вторым параметром передаем нашу data(base64),третьим параметром указываем опцию,что этот файл будет форматом 'base64'

        return res.status(200).json({message:"Загружено"}); // возвращаем на клиент статус код 200 и передаем объект сообщения в json(),указываем там поле message с текстом 

    }catch(e){

        console.log(e);

        return res.status(500).json('error'); // отправляем на клиент статус код 500(то есть произошла ошибка) и в тело ответа(в json()) указываем строку с текстом

    }

});

app.get('/image', (req,res) => {

    // используем try catch для обработки ошибок
    try{

        const file = fs.readFileSync(path.resolve('files',`${req.query.id}.jpg`)); // указываем readFileSync(),то есть читаем файл,первым параметром указываем путь до этого файла,который нужно прочитать,передаем путь до папки с помощью path.resolve() (он берет относительный путь до корневой папки,в данном случае до папки server),передаем в нее название папки,в которой находится файл(files в данном случае),и потом указываем название файла,берем это название из id(req.query.id),который будем передавать query параметром в url к этому эндпоинту,то есть это тот самый id сессии

        const data = `data:image/png;base64,` + file.toString('base64'); // помещаем в переменную data кусок строки,который убирали в эндпоинте post запроса /image выше в коде и добавляем к ней сам файл,который в переменной file,используем toString('base64') к этому файлу,чтобы привести его к формату base64

        return res.json(data); // возваращаем на клиент data(файл картинки)


    }catch(e){

        console.log(e);

        return res.status(500).json('error'); // отправляем на клиент статус код 500(то есть произошла ошибка) и в тело ответа(в json()) указываем строку с текстом

    }

})


app.listen(PORT, () => console.log(`Server started on PORT = ${PORT}`));  // запускаем сервер,говоря ему прослушивать порт 5000(указываем первым параметром у listen() нашу переменную PORT) с помощью listen(),и вторым параметром указываем функцию,которая выполнится при успешном запуске сервера

const connectionHandler = (ws,msg) => {

    // чтобы отделять сессии,будем присваивать вебсокету id,это будет id той сессии,в которой пользователь сейчас находится,чтобы у разных пользователей была отдельная сессия,типа один пользователь открыл один холст, другой пользователь другой холст,и еще другие рисуют на одном холсте вместе
    ws.id = msg.id; // указываем id этому вебсокету как id у этого сообщения(msg)

    broadcastConnection(ws,msg); // вызываем нашу функцию broadcastConnection(),передаем туда параметрами ws(вебсокет) и msg(сообщение)

}

const broadcastConnection = (ws,msg) => {

    // в clients находятся все открытые вебсокеты(подключения с пользователями) на данный момент, с помощью forEach пробегаемся по этому массиву clients
    aWss.clients.forEach(client => {
        
        // если id у client равен id у msg,то есть если id клиента равняется id у этого сообщения(msg),то есть должна быть одна сессия,этот id для клиента(вебсокета,текущего подключения к пользователю) присваеваем в нашей функции connectionHandler() при подключении к вебсокет серверу,то есть когда на сервер при подключении к этому вебсокету придет сообщение от клиента(фронтенда) типа,что подключение установлено(или может быть любое другое сообщение),то у этого сообщения будет id,и этот id будет присвоен этому вебсокету(отдельному подключению к пользователю на данный момент),и тогда это сообщение в client.send() в коде ниже будет отправлено каждому отдельному пользователю(который сейчас подключен к вебсокет серверу) по id,который есть у этого сообщения
        if(client.id === msg.id){

            // закомментировали это,так как уже отправляем объект сообщения(обернутый в JSON.stringify()) на клиент
            // client.send(`Пользователь ${msg.username} подключился`); // отправляем на клиент сообщение

            client.send(JSON.stringify(msg)); // отправляем сообщение на клиент,которое получили с клиента(то есть когда пришло сообщение на сервер от клиента,то мы его сразу отправляем на клиент всем участникам сессии(типа текущего подключения к вебсокету с определенным id) ), с помощью send() у этого client,в него передаем объект сообщения,обернутый в JSON.stringify(),он преобразовывает объекты в строковый формат,делаем это,так как обмениваться сообщениями через вебсокеты можно только в строковом формате

        }

    });

}
