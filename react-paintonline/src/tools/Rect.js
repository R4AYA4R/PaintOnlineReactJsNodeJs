import Tool from "./Tool";

// создаем и экспортируем класс Rect,который расширяет(то есть наследуется) наш класс Tool,то есть наш класс Rect будет иметь те же переменные и методы(функции),что имеет наш класс Tool,а также дополнительный переменные и методы,которые мы укажем здесь у этого класса Rect
export default class Rect extends Tool {

    // создаем конструктор,у которого будет параметр canvas,socket(вебсокет),id(типа id сессии,то есть id текущего подключения к вебсокет серверу)
    constructor(canvas, socket, id) {

        super(canvas, socket, id); // super() вызывает конструктор родительского класса(то есть в данном случае вызывает конструктор нашего класса Tool),куда передаем параметры canvas,socket,id конструктора этого класса Rect

        this.listen(); // вызываем нашу функцию listen(),то есть после создания объекта на основе этого класса Rect,наш canvas будет слушать все эти функции(типа прослушивать события,которые мы указали в функции listen)

    }

    // создаем функцию,в которой будем добавлять слушатели событий на наш канвас
    listen() {

        this.canvas.onmousemove = this.mouseMoveHandler.bind(this); // при событии onmouseMove(то есть когда пользователь будет двигать мышкой) присваеваем нашу функцию mouseMoveHandler,которую биндим( bind() ) к текущему контексту,чтобы мы могли обращаться в этой нашей функции к this

        this.canvas.onmousedown = this.mouseDownHandler.bind(this);

        this.canvas.onmouseup = this.mouseUpHandler.bind(this);

    }

    // создаем метод(функцию),которая будет отрабатывать,когда пользователь отпустил мышку с канваса,параметром принимает e,то есть это будет ссылка на канвас
    mouseUpHandler(e) {

        this.mouseDown = false; // указываем полю mouseDown у этого класса значение как false,то есть типа кнопка мыши отпущена(когда пользователь отпустит нажатие кнопки мыши)

        // отправляем на вебсокет сервер сообщение,то есть объект,обернутый в JSON.stringify(),так как обмен сообщениями с вебсокет сервером происходит в формате строки,отправляем этот объект,чтобы остальные участники сессии(текущего подключения к вебсокет серверу по определенному id) могли увидеть то,что сейчас рисуется
        this.socket.send(JSON.stringify({

            method: 'draw',

            id: this.id,

            // указываем объект фигуры,которую будем рисовать
            figure: {

                type: 'rect', // указываем тип этой фигуры,в данном случае 'rect' для рисования прямоугольника

                x: this.startX, // указываем координату по x,чтобы рисовать прямоугольник от начала этой координаты,указываем поле this(этого класса).startX этого класса,ниже в функции mouseDownHandler() указали ей значение

                y: this.startY, // указываем координату по y,чтобы рисовать прямоугольник от начала этой координаты,указываем поле this(этого класса).startY этого класса,ниже в функции mouseDownHandler() указали ей значение

                width: this.width, // указываем ширину прямоугольника,указываем поле this(этого класса).width этого класса,ниже в функции mouseDownHandler() указали ей значение

                height: this.height, // указываем высоту прямоугольника,указываем поле this(этого класса).height этого класса,ниже в функции mouseDownHandler() указали ей значение

                color: this.ctx.fillStyle // указываем цвет фигуры, берем его из текущего контекста канваса (this.ctx) и у него поле fillStyle

            }

        }))

    }

    // создаем метод(функцию),которая будет отрабатывать,когда пользователь нажал мышку на канвасе,параметром принимает e,то есть это будет ссылка на канвас
    mouseDownHandler(e) {

        this.mouseDown = true; // указываем полю mouseDown у этого класса значение как true,то есть типа кнопка мыши нажата

        this.ctx.beginPath(); // вызываем метод beginPath() у нашей переменной ctx(контекст канваса),которую создавали в классе Tool,beginPath() говорит о том,что мы начали рисовать новую линию

        this.startX = e.pageX - e.target.offsetLeft; // переменная для стартовой позиции по координате x(указываем ей this(то есть переменная этого класса),чтобы потом получить доступ к ней в другой функции этого класса),из координаты мыши относительно страницы по координате x(e.pageX) мы отнимает левый отступ канваса от края страницы(e.target.offsetLeft)

        this.startY = e.pageY - e.target.offsetTop;  // переменная для стартовой позиции по координате y(указываем ей this(то есть переменная этого класса),чтобы потом получить доступ к ней в другой функции этого класса),из координаты мыши относительно страницы по координате y(e.pageY) отнимаем  верхний отступ канваса от края страницы(e.target.offsetTop)

        this.saved = this.canvas.toDataURL(); // сохраняем изображение с канваса с помощью toDataURL() в переменную this(типа этого класса).saved,это чтобы рисовался только один прямоугольник,когда двигаем мышью с зажатой левой кнопкой мыши,а не рисовались бесконечно прямоугольники

    }

    // создаем метод(функцию),которая будет отрабатывать,когда пользователь двигает мышку на канвасе
    mouseMoveHandler(e) {

        // если поле mouseDown у этого класса true,то будем рисовать
        if (this.mouseDown) {

            let currentX = e.pageX - e.target.offsetLeft; // когда переместили мышку,то нужно запоминать и эту координату по x,чтобы мы могли высчитать ширину и высоту,из координаты мыши относительно страницы по координате x(e.pageX) мы отнимает левый отступ канваса от края страницы(e.target.offsetLeft)

            let currentY = e.pageY - e.target.offsetTop; // когда переместили мышку,то нужно запоминать и эту координату по y,чтобы мы могли высчитать ширину и высоту,из координаты мыши относительно страницы по координате y(e.pageY) отнимаем  верхний отступ канваса от края страницы(e.target.offsetTop)

            this.width = currentX - this.startX; // из текущей координаты(курсора мыши,когда его переместили после нажатия левой кнопки мыши) по x,отнимаем this.startX(начальную координату курсора мыши по x,когда только нажали левую кнопку мыши,this тут,типа этот класс,переменная этого класса)

            this.height = currentY - this.startY; // из текущей координаты(курсора мыши,когда его переместили после нажатия левой кнопки мыши) по y,отнимаем this.startY(начальную координату курсора мыши по y,когда только нажали левую кнопку мыши,this тут,типа этот класс,переменная этого класса)


            this.draw(this.startX, this.startY, this.width, this.height); // вызываем нашу функцию draw() у этого класса,передаем параметрами координаты курсора мыши по x, y, this.width(ширину для прямоугольника),this.height(высоту для прямоугольника)

        }

    }

    // создаем функцию draw для рисования квадрата,в параметрах она принимает x(начальная координата по x),y(начальная координата по y),w(ширина прямоугольника),h(высота прямоугольника)
    draw(x, y, w, h) {

        const img = new Image(); // создаем объект на основе класса Image

        img.src = this.saved; // в атрибут(поле) src передаем изображение,которое сохранили в переменную this(типа этого класса).saved 

        // реализовываем слушатель события onload,который сработает,когда изображение установилось,эта операция не мнгновенная,поэтому эта функция асинхронная
        img.onload = () => {

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // очищаем канвас полностью от тех фигур с помощью clearRect(параметрами принимает координаты по x,y,ширину и высоту канваса),которые нарисовали,то есть когда водим мышкой с зажатой левой клавишей мыши,рисуется куча квадратов,их и очищаем,чтобы видеть только текущий объект(прямоугольник)

            // так как вы очищаем весь канвас с помощью clearRect(),нам нужно вернуть старые рисунки,которые были до этого,для этого и сохраняли изображение канваса в переменную this(типа этого класса).saved, первым параметром drawImage() принимает изображение(img в данном случае,то есть картинку которую помещали в переменную this.saved),вторым параметром координату начальной точки x на канвасе,третьим параметром координату начальной точки y на канвасе,4 и 5 параметром принимает ширину и высоту канваса
            this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);

            this.ctx.beginPath(); // с помощью beginPath() говорим о том,что начинаем рисовать новую фигуру

            this.ctx.rect(x, y, w, h); // у ctx(контекста) есть метод rect(),который рисует прямоугольник,параметрами передаем координату курсора мыши по x(начальная координата по x),y(начальная координата по y),w(ширина прямоугольника),h(высота прямоугольника),эти параметры берем из параметров этой функции draw,их передаем в нее в нашей функции mouseMoveHandler()

            this.ctx.fill(); // fill() - заполняет цветом прямоугольник,который мы нарисовали

            this.ctx.stroke(); // делаем обводку нарисованного прямоугольника

        }

    }

    // указываем функции static,чтобы можно было ее вызывать без создания объекта на основе этого класса, создаем функцию staticDraw для рисования квадрата,в параметрах она принимает ctx(контекст канваса), x(начальная координата по x),y(начальная координата по y),w(ширина прямоугольника),h(высота прямоугольника), color(цвет фигуры)
    static staticDraw(ctx, x, y, w, h, color) {

        ctx.fillStyle = color; // меняем цвет контекста канваса(прямоугольника в данном случае) с помощью fillStyle на color(параметр этой функции staticDraw)

        ctx.beginPath(); // с помощью beginPath() говорим о том,что начинаем рисовать новую фигуру

        ctx.rect(x, y, w, h); // у ctx(контекста) есть метод rect(),который рисует прямоугольник,параметрами передаем координату курсора мыши по x(начальная координата по x),y(начальная координата по y),w(ширина прямоугольника),h(высота прямоугольника),эти параметры берем из параметров этой функции draw,их передаем в нее в нашей функции mouseMoveHandler()

        ctx.fill(); // fill() - заполняет цветом прямоугольник,который мы нарисовали

        ctx.stroke(); // делаем обводку нарисованного прямоугольника

    }

}