

import { makeAutoObservable } from 'mobx'; // импортируем makeAutoObservable из mobx,чтобы сделать данные,которые хранятся в этом классе, отслеживаемыми для mobx

class CanvasState {

    canvas = null; // указываем поле tool со значением null по дефолту

    socket = null; // указываем поле socket со значением null по дефолту

    sessionid = null; // указываем поле sessionid со значением null по дефолту

    undoList = []; // массив для всех действий,которые когда-либо делали(это чтобы сделать возврат действия назад(отменить действие))

    redoList = []; // массив для всех действий,которые отменяли(это чтобы сделать возврат действия вперед)

    username = ""; // переменная для имени пользователя


    constructor(){

        makeAutoObservable(this); // вызываем метод makeAutoObservable() и передаем туда this,чтобы сделать данные,которые хранятся в этом классе, отслеживаемыми для mobx,и когда будем изменять данные в этом классе,реакт будет отслеживать это и перерендеривать компонент

    }

    // создаем функию,которая меняет поле username у этого состояния у mobx,на параметр этой функции username
    setUsername(username){

        this.username = username;

    }

    // создаем функию,которая меняет поле sessionid у этого состояния у mobx,на параметр этой функции id
    setSessionId(id){

        this.sessionid = id;

    }

    // создаем функию,которая меняет поле socket у этого состояния у mobx,на параметр этой функции socket
    setSocket(socket){

        this.socket = socket;

    }

    // создаем функцию(типа action как в redux toolkit),которая будет изменять поле canvas в данном случае,то есть будем изменять ссылку на сам canvas
    setCanvas(canvas){

        this.canvas = canvas; // изменяем поле canvas этого класса(this) на параметр этой функции canvas

    }

    pushToUndo(data) {

        this.undoList.push(data); // добавляем в массив undoList(массив для всех действий,которые когда-либо делали) параметр data(параметр этой функции pushToUndo)
        
    }

    pushToRedo(data){

        this.redoList.push(data); // добавляем в массив redoList(массив для всех действий,которые отменяли) параметр data(параметр этой функции pushToUndo)

    }

    // функция для возврата действия назад(отмены действия)
    undo(){
        
        let ctx = this.canvas.getContext('2d'); // получаем контекст этого канваса(this.canvas.getContext('2d'), указываем '2d' в getContext(),чтобы указать,что этот канвас взаимодействует с 2d объектами,так как канвас может взаимодействовать и с 3d объектами) и помещаем его в переменную ctx

        // если this.undoList.length больше 0,то есть длина массива undoList больше 0,то делаем это,в другом случае очищаем канвас
        if(this.undoList.length > 0){

            let dataUrl = this.undoList.pop(); // достаем последний элемент из массива undoList с помощью pop() и помещаем его в переменную dataUrl

            this.redoList.push(this.canvas.toDataURL()); // помещаем в массив redoList(массив для всех действий,которые отменяли,это чтобы вернуть действие вперед) this.canvas.toDataURL()(текущее состояние канваса,то есть как он выглядит сейчас,делаем картинку этого канваса с помощью toDataURL())

            let img = new Image(); // создаем объект на основе класса Image() (дефолтный класс в javascript)

            img.src = dataUrl; // помещаем в путь картинки dataUrl(последний взятый снимок с канваса)

            // когда изображение будет установлено(onload) делаем это
            img.onload = () => {

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // очищаем канвас полностью от тех фигур с помощью clearRect(параметрами принимает координаты по x,y,ширину и высоту канваса),которые нарисовали,очищаем с верхнего левого угла(x координата 0, y координата 0) по всей ширине и высоте канваса

                ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height); // после того,как очистили канвас с помощью clearRect(),нам нужно вернуть рисунки до этого,то есть действие до этого,для этого и доставали последнее изображение канваса из массива undoList и помещали его в dataUrl, первым параметром drawImage() принимает изображение(img в данном случае,то есть саму картинку),вторым параметром координату начальной точки x на канвасе,третьим параметром координату начальной точки y на канвасе,4 и 5 параметром принимает ширину и высоту канваса

            }

        } else {

            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // очищаем канвас полностью от тех фигур с помощью clearRect(параметрами принимает координаты по x,y,ширину и высоту канваса),которые нарисовали,очищаем с верхнего левого угла(x координата 0, y координата 0) по всей ширине и высоте канваса

        }

    }

    // функция для возврата действия вперед
    redo(){

        let ctx = this.canvas.getContext('2d'); // получаем контекст этого канваса(this.canvas.getContext('2d'), указываем '2d' в getContext(),чтобы указать,что этот канвас взаимодействует с 2d объектами,так как канвас может взаимодействовать и с 3d объектами) и помещаем его в переменную ctx

        // если this.redoList.length больше 0,то есть длина массива redoList больше 0,то делаем это,в другом случае очищаем канвас
        if(this.redoList.length > 0){

            let dataUrl = this.redoList.pop(); // достаем последний элемент из массива redoList с помощью pop() и помещаем его в переменную dataUrl

            this.undoList.push(this.canvas.toDataURL()); // помещаем в массив undoList(массив для всех действий,которые когда-либо делали,это чтобы потом отменить действие) this.canvas.toDataURL()(текущее состояние канваса,то есть как он выглядит сейчас,делаем картинку этого канваса с помощью toDataURL())

            let img = new Image(); // создаем объект на основе класса Image() (дефолтный класс в javascript)

            img.src = dataUrl; // помещаем в путь картинки dataUrl(последний взятый снимок с канваса)

            // когда изображение будет установлено(onload) делаем это
            img.onload = () => {

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // очищаем канвас полностью от тех фигур с помощью clearRect(параметрами принимает координаты по x,y,ширину и высоту канваса),которые нарисовали,очищаем с верхнего левого угла(x координата 0, y координата 0) по всей ширине и высоте канваса

                ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height); // после того,как очистили канвас с помощью clearRect(),нам нужно вернуть рисунки до этого,то есть действие до этого,для этого и доставали последнее изображение канваса из массива undoList и помещали его в dataUrl, первым параметром drawImage() принимает изображение(img в данном случае,то есть саму картинку),вторым параметром координату начальной точки x на канвасе,третьим параметром координату начальной точки y на канвасе,4 и 5 параметром принимает ширину и высоту канваса

            }

        } 

    }

}

export default new CanvasState(); // экспортируем объект на основе нашего класса ToolState(),в данном случае это будет состояние,которое мы будем использовать